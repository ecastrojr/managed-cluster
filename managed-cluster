#!/usr/bin/env bash

${DEBUG:=false} && set -x
: ${INSIDE_CONTAINER:=false}

if [ -d /opt/homebrew/Cellar/coreutils/9.0/libexec/gnubin ]; then
    export PATH="/opt/homebrew/Cellar/coreutils/9.0/libexec/gnubin:$PATH"
fi

if $INSIDE_CONTAINER; then
    export ROOT_DIR=$REPO_DIR
    source /etc/profile.d/getup.sh
else
    export ROOT_DIR=$(readlink -nf $(dirname $0))
    export REPO_DIR=$ROOT_DIR
    export PATH="$PATH:$ROOT_DIR/root/usr/local/bin/"

    # Globals set in getup.sh:
    # REPO_DIR: git repo root dir, or from docker image envs
    # REPO_CONF: file path to repo.conf
    # CLUSTER_CONF: file path fo cluster.conf
    # TEMPLATES_DIR: dir path to $REPO_DIR/templates/
    source $ROOT_DIR/root/etc/profile.d/getup.sh
fi

if [ -t 0 ]; then
    COLOR_RED="$(tput setaf 1)"
    COLOR_GREEN="$(tput setaf 2)"
    COLOR_YELLOW="$(tput setaf 3)"
    COLOR_BOLD="$(tput bold)"
    COLOR_RESET="$(tput sgr0)"
fi

function copy_from_template_common()
{
    local cmd="rsync -va --checksum --omit-dir-times $@ ${common_template_files[@]/#/$TEMPLATES_DIR/} $CLUSTER_DIR/"
    info "--> $cmd"
    $cmd
}

function copy_from_template_provider()
{
    local cmd="rsync -va --checksum --omit-dir-times $@ $TEMPLATE_DIR/ $CLUSTER_DIR/"
    info "--> $cmd"
    $cmd
}

function sync_from_template()
{
    if ! [ -d "$CLUSTER_DIR" ]; then
      warn "Cluster dir not found: $CLUSTER_DIR"
      return 1
    fi

    if ! [ -e "$REPO_CONF" ]; then
      warn "Missing file: $REPO_CONF"
      return 1
    fi

    if ! [ -e "$CLUSTER_CONF" ]; then
      warn "Missing file: $CLUSTER_CONF"
      return 1
    fi

    local rsync_params="--out-format=%n --info=all0,name1 --exclude=manifests/cluster/ --exclude=manifests/base/kustomization.yaml --exclude=provider.env --exclude=\*.swp"
    local files_to_sync_common=( $(copy_from_template_common $rsync_params --dry-run) )
    local files_to_sync_provider=( $(copy_from_template_provider $rsync_params --dry-run) )

    if (( ${#files_to_sync_common[*]} + ${#files_to_sync_provider[*]} == 0 )); then
        info Nothing to sync
        return
    fi

    if ! $force; then
        info "Will sync files below:"
        echo
        echo "${COLOR_BOLD}--[ Updates from $TEMPLATES_DIR ]--${COLOR_RESET}"
        echo ${files_to_sync_common[*]} | sed -e "s/\s/\n/g" #| sed -e "s/^/+ /"
        echo
        echo "${COLOR_BOLD}--[ Updates from $TEMPLATE_DIR ]--${COLOR_RESET}"
        echo ${files_to_sync_provider[*]} | sed -e "s/\s/\n/g" #| sed -e "s/^//"

        while true; do
            ask_any "Please choose an action [Yes/No/Diff]:"
            case ${ask_response,,} in
                y|yes|s|sim)
                    break
                ;;
                n|no|nao)
                    return
                ;;
                d|diff)
                    {
                        for file in ${files_to_sync_common[@]}; do
                            if [ -f "$TEMPLATES_DIR/$file" ] || [ -L "$TEMPLATES_DIR/$file" ]; then
                                diff -puN --color=always $CLUSTER_DIR/${file} $TEMPLATES_DIR/${file}
                            fi
                        done
                        for file in ${files_to_sync_provider[@]}; do
                            if [ -f "$TEMPLATE_DIR/$file" ] || [ -L "$TEMPLATE_DIR/$file" ]; then
                                diff -puN --color=always $CLUSTER_DIR/${file} $TEMPLATE_DIR/${file}
                            fi
                        done
                    } | less -rXF
                ;;
                *)
                    continue
            esac
        done
    fi

    copy_from_template_common $rsync_params
    copy_from_template_provider $rsync_params
}

function merge_requires()
{
    local requires_txt=$TEMPLATE_DIR/requires.txt
    local source_requires_tf=$TEMPLATES_DIR/requires.tf
    local target_requires_tf=$CLUSTER_DIR/requires.tf

    if ! [ -e "$requires_txt" ]; then
        return
    fi

    sed -e "/# requires.txt placeholder.*/r $requires_txt" < $source_requires_tf > $target_requires_tf
    if type terraform &>/dev/null; then
        terraform fmt $target_requires_tf
    fi
}

#function require_config()
#{
#    local _name="${1}"
#    local _description="${2}"
#    local _filename="${3}"
#
#    # use value if already exists
#    if [ -n "${!_name}" ]; then
#        set_config ${_name}="${!_name}" "$_description" $_filename
#        return 0
#    fi
#
#    until read_config "$_name" "$_description"; do
#        warn "Value can't be empty"
#    done
#
#    local _value="${!_name}"
#    set_config "$_name='$_value'" "$_description" $_filename
#}

function list_cluster_types()
{
    local types=( templates/*/ )
    types=( ${types[@]#*/} )
    types=( ${types[@]%/} )
    types=( "${types[@]/manifests}" ) ## remove manifests from types
    echo ${types[*]}
}

function select_cluster_type()
{
    # use value if already exists
    if [ -n "$opt_type" ]; then
        for i in $(list_cluster_types); do
            if [ "$opt_type" == "$i" ]; then
                export type="$opt_type"
                return
            fi
        done
        warn Invalid cluster type: $opt_type
        return 1
    fi

    local types=$(list_cluster_types)
    local PS3=$(prompt "Select cluster type")

    select type in ${types}; do
        break;
    done

    export type
}

function select_cluster_sla()
{
    if [ -n "$opt_sla" ]; then
        case "$opt_sla" in
            high|low|none)
                export sla=$opt_sla
                return
            ;;
        esac
        warn Invalid cluster SLA: $opt_sla
        return 1
    fi

    local PS3=$(prompt "Select cluster SLA")

    select sla in "high (prod|hlg)" "low (dev|test)" "none (no remote-ops)"; do
        sla=$(cut -f1 -d' ' <<<$sla)
        case "$sla" in
            high|low|none)
                break;
        esac
    done

    export sla
}

function generate_ssh_key()
{
    local _key_priv=$CLUSTER_DIR/identity
    local _key_pub=$CLUSTER_DIR/identity.pub
    local _kh=$CLUSTER_DIR/known_hosts

    if ! [ -e $_key_priv ]; then
        info Generating $_key_priv
        ssh-keygen -t $ssh_key_type -b $ssh_key_length -f $_key_priv -N "" -C "$customer/$name/$type"
    else
        info Using existing $_key_priv
    fi

    if ! [ -e $_key_pub ]; then
        ssh-keygen -yf $_key_priv > $_key_pub
    fi

    info Generating $_kh for $ssh_host
    ssh-keyscan $ssh_host > $_kh

    if $opt_local_git_repo; then
        info Updating local ssh config
        local _key_pub_data=$(cut -f1-2 -d' ' $_key_pub)
        local _key_fp=$(ssh-keygen -l -E md5 -f $_key_pub | cut -f2 -d' ')
        if ! grep -q "$_key_pub_data" ~/.ssh/authorized_keys; then
            info "Appending ssh key ($_key_fp) to $HOME/.ssh/authorized_keys"
            cat $_key_pub >> $HOME/.ssh/authorized_keys
            chmod 600 $HOME/.ssh/authorized_keys
        fi
    fi
}

function select_cluster()
{
    local cluster_dir=""

    if $INSIDE_CONTAINER; then
        # already set
        return
    fi

    if [ $# -eq 0 ]; then
        local candidate_clusters=( clusters/*/*/ )
    else
        candidate_clusters=( $@ )
    fi

    candidate_clusters=( ${candidate_clusters[*]%/} )

    if [ ${#candidate_clusters[*]} -eq 1 ]; then
        export CLUSTER_DIR=$candidate_clusters
        export CLUSTER_CONF=$CLUSTER_DIR/cluster.conf
        if ! has_valid_config $CLUSTER_CONF; then
            warn Config not found: $CLUSTER_CONF
            return 1
        fi

        update_globals
        return
    fi

    cluster_names=( ${candidate_clusters[*]#*/} )
    cluster_names=( ${cluster_names[*]%/*} )
    cluster_types=( ${candidate_clusters[*]##*/} )

    if type fzf &>/dev/null; then
        cluster_dir=$(printf '%s\n' ${candidate_clusters[*]} | awk '{print FNR, $0}' |
            fzf -1 --ansi --no-preview --cycle --reverse --header='---[ Select Cluster ]---' | awk '{print $2}')
    elif type dialog &>/dev/null; then
        exec 3>.tmp
        eval dialog --output-fd 3 --menu "'Select cluster'" 0 0 0 \
            "$(for i in $(seq 0 $(( ${#candidate_clusters[*]} - 1 )) ); do echo -n " $((i + 1)) '[${cluster_types[$i]}] ${cluster_names[$i]}'"; done)" \
            '---' '---' \
            b "'Bootstrap cluster'"  >&2
            #s 'Sync from template' >&2
        idx=$(<.tmp)
        rm -f .tmp
        let idx--
        case "$idx" in
            [0-9]*)
                cluster_dir=${candidate_clusters[$idx]}
            ;;
            *) cluster_dir=$idx
        esac
    else
        local PS3="${COLOR_GREEN}${COLOR_BOLD}Select cluster to start: ${COLOR_RESET} "

        select cluster_dir in ${candidate_clusters[*]}; do
            export CLUSTER_CONF=$cluster_dir/cluster.conf
            if has_valid_config $cluster_dir; then
                break
            else
                warn Config not found: $CLUSTER_CONF
            fi
        done
    fi

    export CLUSTER_DIR=$cluster_dir
    update_globals
}

function assert_cluster_dir()
{
    if [ -z "$CLUSTER_DIR" ]; then
        warn "Missing cluster dir"
        exit 1
    fi

    if ! [ -e "$CLUSTER_CONF" ]; then
        warn "Invalid or missing cluster config: $CLUSTER_CONF"
        exit 1
    fi
}

function update_git_remotes()
{
    line
    info Updating remotes

    if [ -z "$upstream" ]; then
        warn Missing UPSTREAM remote
        return 1
    fi

    if [ -z "$origin" ]; then
        warn Missing ORIGIN remote
        return 1
    fi

    git remote remove upstream 2>/dev/null || true
    git remote add upstream "$upstream"
    git remote set-url --push upstream FORBIDEN

    git remote remove origin 2>/dev/null || true
    git remote add origin $origin
}

function start_container()
{
    assert_cluster_dir

    if $run_as_root; then
        : ${CONTAINER_USER_ID:=0}
        : ${CONTAINER_GROUP_ID:=0}
    else
        : ${CONTAINER_USER_ID:=$(id -u)}
        : ${CONTAINER_GROUP_ID:=$(id -g)}
    fi

    local docker_run_options_defaults=(
        --cap-add=SYS_PTRACE
        --network host
        --rm
        -it
        --env-file $ROOT_DIR/.dockerenv
        -v $(readlink -nf $CLUSTER_DIR):/cluster
        -v $ROOT_DIR:/repo
        -v $HOME:/home/_host:ro
    )

    if [ -e /var/run/docker.sock ]; then
        docker_run_options_defaults+=(
            -v /var/run/docker.sock:/var/run/docker.sock
        )
    fi

    if [ -e "$SSH_AUTH_SOCK" ]; then
        docker_run_options_defaults+=(
            -v "$SSH_AUTH_SOCK:$SSH_AUTH_SOCK"
            --env "SSH_AGENT_PID:$SSH_AGENT_PID"
            --env "SSH_AUTH_SOCK:$SSH_AUTH_SOCK"
        )
    fi

    {
        echo CONTAINER_USER_ID=$CONTAINER_USER_ID
        echo CONTAINER_GROUP_ID=$CONTAINER_GROUP_ID
        echo GH_TOKEN=$GH_TOKEN
        echo debug=$debug
        echo verbose=$verbose
    } > .dockerenv

    if $force_docker_image_build; then
        make
    fi

    check_deprecations

    info Starting cluster: $CLUSTER_DIR with docker image ${docker_image}
    docker_run="docker run ${docker_run_options_defaults[@]} ${docker_image} ${docker_command}"
    info \$ $docker_run
    #echo
    eval $sudo $docker_run
}

function get_local_ip()
{
    if which ip &>/dev/null; then
        ip r \
            | awk '/^default/{print $5}' \
            | head -n1 \
            | xargs ip -4 -o a show dev \
            | awk '{print $4}' \
            | cut -f1 -d /
    else
        netstat -nr \
            | awk '/^default/{print $4}' \
            | head -n1 \
            | xargs ifconfig \
            | awk '/inet /{print $2}'
    fi
}

###########
## Start ##
###########

function usage()
{
    echo "Usage: $0 COMMAND [OPTIONS...] "
    echo
    echo "Creates and manage CLUSTER-DIR (./clusters/\$name/\$type/) from outside manager container."
    if [ -z "$command" ]; then
        echo
        echo "Available commands and options:"
        echo
        echo "    -d, --debug      Turn bash debug messages on (set -x). Implies --verbose."
        echo "    -h, --help       This help message."
        echo "    -v, --verbose    Turn verbose messages on."
    else
        echo
        echo "Run \`$0 --help\` for full help."
    fi

    if [ -z "$command" ] || [ "$command" == "create" ]; then
        echo "${COLOR_BOLD}$COLOR_GREEN"
        echo "  -> create [OPTIONS...]" "$COLOR_RESET${COLOR_BOLD}"
        echo "     Creates a new cluster from ./templates/\$type into CLUSTER-DIR (./clusters/\$name/\$type/)." "$COLOR_RESET"
        echo
        echo "     -c, --customer NAME        Customer name."
        echo "         --force                Force create even if CLUSTER-DIR exists."
        echo "     -f, --flux-git-repo URL    Define flux git repository address. Defaults to ORIGIN. (format: ssh://user@host/path/to/repo)."
        echo "         --local-git-repo       Force flux-git-repo to '$local_git_repo'. Implies -f and -H. (default: false)"
        echo "     -k, --ssh-key-type         SSH key type (default: $ssh_key_type)."
        echo "     -l, --ssh-key-length       SSH key length, depends on ssh key type."
        echo "     -H, --ssh-host             SSH host (default: $ssh_host)."
        echo "     -n, --name NAME            Unique name for new cluster."
        echo "     -o, --origin REMOTE        Define ORIGIN remote address."
        echo "     -s, --sla VALUE            Cluster SLA: high, low, none (default: $opt_sla)."
        echo "     -t, --type NAME            Cluster type: $(list_cluster_types)."
        echo "     -u, --upstream REMOTE      Define UPSTREAM remote address (default: $default_upstream)."
    fi

    if [ -z "$command" ] || [ "$command" == "install-teleport" ]; then
        echo "${COLOR_BOLD}$COLOR_GREEN"
        echo "  -> install-teleport-agent" "$COLOR_RESET${COLOR_BOLD}"
        echo "     Installs teleport-agent as a systemd service" "$COLOR_RESET"
        echo
    fi

    if [ -z "$command" ] || [ "$command" == "start" ]; then
        echo "${COLOR_BOLD}$COLOR_GREEN"
        echo "  -> start [CLUSTER-DIR] [OPTIONS...] [--] [params...]" "$COLOR_RESET${COLOR_BOLD}"
        echo "     Start container for a cluster, passing optional \`docker run -- params\`." "$COLOR_RESET"
        echo
        echo "         --force-docker-image-build        Force building local docker image."
        echo "     -i, --image NAME                      Image name (default: $docker_image)."
        echo "         --no-sudo                         Dont use 'sudo' to run docker."
        echo "     -p, --port-range $port_range          Exposes container port range into host using format FIRST:LAST."
        echo "     -r, --run-as-root                     Run container as root."
        echo "     -s, --standalone                      Start from standalone dir \`./standalone\`."
    fi

    if [ -z "$command" ] || [ "$command" == "sync-template" ]; then
        echo "${COLOR_BOLD}$COLOR_GREEN"
        echo "  -> sync-template [CLUSTER-DIR] [OPTIONS...]" "$COLOR_RESET${COLOR_BOLD}"
        echo "     Sync files from ./templates/\$type into CLUSTER-DIR." "$COLOR_RESET"
        echo
        echo "         --force                    Force template sync."
    fi

    if [ -z "$command" ] || [ "$command" == "repo-pull" ]; then
        echo "${COLOR_BOLD}$COLOR_GREEN"
        echo "  -> repo-pull" "$COLOR_RESET${COLOR_BOLD}"
        echo "     Pull from both remotes 'upstream' and 'origin'." "$COLOR_RESET"
    fi

    if [ -z "$command" ] || [ "$command" == "remote-setup" ]; then
        echo "${COLOR_BOLD}$COLOR_GREEN"
        echo "  -> remote-setup [OPTIONS...]" "$COLOR_RESET${COLOR_BOLD}"
        echo "     Update local remote upstream." "$COLOR_RESET"
        echo
        echo "     -f, --flux-git-repo URL      Define flux git repository address. Defaults to ORIGIN. (format: ssh://user@host/path/to/repo)."
        echo "     -o, --origin REMOTE          Define ORIGIN remote address."
        echo "     -u, --upstream REMOTE        Define UPSTREAM remote address (default: $default_upstream)."
    fi

    if [ -z "$command" ] || [ "$command" == "update-ssh-key" ]; then
        echo "${COLOR_BOLD}$COLOR_GREEN"
        echo "  -> update-ssh-key [CLUSTER-DIR] [OPTIONS...]" "$COLOR_RESET${COLOR_BOLD}"
        echo "     Creates a new ssh key (doesn't pushes to git repo)." "$COLOR_RESET"
        echo
        echo "     -k, --ssh-key-type              New SSH key type (default: $ssh_key_type)."
        echo "     -l, --ssh-key-length            SSH key length, depends on ssh key type."
    fi

#    if [ -z "$command" ] || [ "$command" == "import-variables" ]; then
#        echo "$COLOR_GREEN"
#        echo "  -> import-variables [PREFIX SOURCE]...  Adds PREFIX to terraform variables from SOURCE." "$COLOR_RESET"
#    fi

    if [ -z "$command" ]; then
        echo
        echo "  SSH default key lengths:"
        echo "    rsa: $ssh_key_length_rsa"
        echo "    dsa: $ssh_key_length_dsa"
        echo "    ecdsa: $ssh_key_length_ecdsa"
    fi

    if [ $# -gt 0 ]; then
        echo
        echo -e "${COLOR_RED}$@${COLOR_RESET}"
        exit_code=1
    fi

    exit ${exit_code:-0}
}

function invalid_argument()
{
    case "$1" in
        -*)
            usage "Invalid option[${BASH_LINENO[0]}]: $@"
        ;;
        *)
            usage "Invalid or missing parameter[${BASH_LINENO[0]}]: $@"
    esac
}

function dump_options()
{
    echo Current options:
    for i in command debug verbose force ssh_key_type ssh_key_length ssh_host \
        standalone docker_command port_range run_as_root \
        force_docker_image_build cluster_dir \
        import_var_prefixes import_var_sources
        do
        echo "  ${!i@A}"
    done
}


##########
## MAIN ##
##########

# defaults
command=''
cluster_dir=""
debug=false
verbose=false
force=false
ssh_key_length_rsa=4096
ssh_key_length_dsa=1024
ssh_key_length_ecdsa=521
ssh_key_type=ecdsa
ssh_key_length=0
ssh_host=github.com
local_git_repo_user=$USER
local_git_repo_address=$(get_local_ip 2>/dev/null)
local_git_repo_path=$PWD
local_git_repo="ssh://${local_git_repo_user}@${local_git_repo_address}${local_git_repo_path}/.git"
default_upstream=git@github.com:getupcloud/managed-cluster.git
common_template_files=(
    manifests
    '*.*'
    .gitignore
)

#####################
## COMMAND: create ##
#####################

opt_origin=
opt_upstream=
opt_customer=
opt_name=
opt_type=
opt_sla=
opt_flux_git_repo=
opt_local_git_repo=false

function getopt_c() { getopt_create "$@"; }
function getopt_create()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            --force)
                force=true
            ;;
            -f|--flux-git-repo)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_flux_git_repo=$1
            ;;
            --local-git-repo)
                opt_local_git_repo=true
                opt_flux_git_repo="$local_git_repo"
                ssh_host="$local_git_repo_address"
                info "Using flux git repo: $local_git_repo"
            ;;
            -o|--origin)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_origin=$1
            ;;
            -u|--upstream)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_upstream=$1
            ;;
            -c|--customer)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_customer=$1
            ;;
            -n|--name)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_name=$1
            ;;
            -t|--type)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_type=$1
            ;;
            -k|--ssh-key-type)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_type=$1
            ;;
            -l|--ssh-key-length)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_length=$1
            ;;
            -H|--ssh-host)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_host=$1
            ;;
            -s|--sla)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_sla=$1
            ;;
            *)
                invalid_argument $1
        esac
        shift
    done

    if [ $ssh_key_length -eq 0 ]; then
        local key_len=ssh_key_length_$ssh_key_type
        ssh_key_length=${!key_len}
    fi
}

function command_c() { command_create "$@"; }
function command_create()
{
    set -e

    if ! [ -e "$REPO_CONF" ]; then
        create_repo_config
    fi

    create_cluster

    if ! has_remote upstream; then
        line
        info Current remotes:
        git remote -v

        update_git_remotes

        line
        info New remotes:
        git remote -v
    fi
}

function create_repo_config()
{
    info Creating $REPO_CONF

    read_config customer "Customer name"

    local current_upstream=$(git_remote upstream)
    [ -z "$upstream" ] && upstream="$origin"
    [ -z "$upstream" ] && upstream="$current_upstream"
    [ -z "$upstream" ] && upstream="$default_upstream"
    read_config upstream "Set UPSTREAM remote"

    [ -z "$origin" ] && origin="$(git-url $(git_remote origin) url2ssh)"
    origin=${origin%.git}-$customer.git
    read_config origin "Set ORIGIN remote"

    flux_git_repo=${origin#git://}
    flux_git_repo=ssh://${flux_git_repo/:/\/}
    read_config flux_git_repo "Flux git repository"

    save_repo_config
}

function save_repo_config()
{
    info Saving $REPO_CONF

    set_config customer="$customer" "Customer name" $REPO_CONF
    set_config upstream="$upstream" "Upstream git repo" $REPO_CONF
    set_config origin="$origin" "Origin git repo" $REPO_CONF
    set_config flux_git_repo="$flux_git_repo" "Git repo for default flux GitRepository" $REPO_CONF
}

function create_cluster()
{
    select_cluster_type
    read_config name "Cluster name"
    select_cluster_sla

    export CLUSTER_DIR=$ROOT_DIR/clusters/$name/$type
    export CLUSTER_CONF=$CLUSTER_DIR/cluster.conf

    mkdir -p ${CLUSTER_DIR}
    save_cluster_config
    update_globals
    copy_from_template_common
    copy_from_template_provider
    merge_requires
    generate_ssh_key
}

function save_cluster_config()
{
    info Saving $CLUSTER_CONF
    set_config type="$type" "Cluster Type" $CLUSTER_CONF
    set_config name="$name" "Cluster Name" $CLUSTER_CONF
    set_config sla="$sla" "Cluster SLA" $CLUSTER_CONF
}

#####################################
## COMMAND: install-teleport-agent ##
#####################################

function getopt_ita() { getopt_install_teleport_agent "$@"; }
function getopt_install_teleport_agent()
{
    :
}

function command_ita() { command_install_teleport_agent "$@"; }
function command_install_teleport_agent()
{
    if $INSIDE_CONTAINER; then
        warn This command must run from outside this container
        exit 1
    fi

    read_config customer "Customer name"
    read_config USERNAME "Username"
    read_config HOSTNAME "Hostname"
    read_config region "Region"

    cat > .teleport-config.tmp <<-EOF
		teleport:
		  nodename: ${customer}-${HOSTNAME}
		ssh_service:
		  enabled: yes
		  labels:
		    region: ${region}
		    user: ${USER}
		    team: "operations"
		EOF

    info 'Go to https://getup.teleport.sh/web/cluster/getup.teleport.sh/nodes and paste the command from "ADD SERVER" below'
    read_config teleport_install_command 'Paste the command here'
    eval "$teleport_install_command"

    info Updating config...
    yq eval-all 'select(fileIndex == 0) * select(fileIndex == 1)' /etc/teleport.yaml .teleport-config.tmp > teleport.yaml
    sudo cp -fv teleport.yaml /etc/teleport.yaml
    rm -f .teleport-config.tmp teleport.yaml
    info Restarting teleport-agent...
    sudo systemctl restart teleport
    info done
}


####################
## COMMAND: start ##
####################

standalone=false
docker_command="" # /bin/bash
port_range=32000-32010
run_as_root=false
docker_image=ghcr.io/getupcloud/managed-cluster:$(make --no-print-directory print-release)
force_docker_image_build=false
sudo=sudo

function getopt_s() { getopt_start "$@"; }
function getopt_start()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            -s|--standalone)
                standalone=true
            ;;
            -P|--port-range)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                port_range=$1
            ;;
            -r|--run-as-root)
                run_as_root=true
            ;;
            --no-sudo)
                sudo=""
            ;;
            -i|--image)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                docker_image=$1
            ;;
            --force-docker-image-build)
                force_docker_image_build=true
            ;;
            --)
                shift
                docker_command="${@@Q}"
                shift $#
            ;;
            *)
                if [ -z "$cluster_dir" ]; then
                    cluster_dir=$1
                else
                    invalid_argument $1
                fi
        esac
        shift
    done

    select_cluster $cluster_dir
}

function check_dependencies()
{
    local status=0

    for bin in jq make; do
        if ! which $bin &>/dev/null; then
            warn "Missing required command: $bin"
            status=1
        fi
    done

    for lib in giturlparse; do
        if ! python3 -c "import $lib; print($lib)" &>/dev/null && ! python -c "import $lib; print($lib)" &>/dev/null; then
            warn "Missing required python lib: $lib"
            status=1
        fi
    done

    return $status
}

function check_deprecations()
{
    local old_cluster_configs=(
        upstream_git_repo
        origin_git_repo
        https_origin_git_repo
        flux_git_repo
    )

    for i in ${old_cluster_configs[*]}; do
        if grep -q $i $CLUSTER_DIR/cluster.conf; then
            warn "DEPRECATED: $CLUSTER_DIR/cluster.conf: $i: Please remove this config."
        fi
    done
}

function command_s() { command_start "$@"; }
function command_start()
{
    if ! check_dependencies; then
        info "Execute 'make install' or install missing command(s) or lib(s)"
        exit 1
    fi

    if $standalone; then
        export CLUSTER_DIR="$PWD/standalone"
        mkdir -p $CLUSTER_DIR
        touch $CLUSTER_DIR/terraform.tfvars
        touch $REPO_CONF
        touch $CLUSTER_CONF
    fi

    update_globals
    start_container
}

############################
## COMMAND: sync-template ##
############################

function getopt_st() { getopt_sync_template "$@"; }
function getopt_sync_template()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            --force)
                force=true
            ;;
            *)
                if [ -z "$cluster_dir" ]; then
                    cluster_dir=$1
                else
                    invalid_argument $1
                fi
        esac
        shift
    done

    select_cluster $cluster_dir
}

function command_st() { command_sync_template "$@"; }
function command_sync_template()
{
    assert_cluster_dir
    sync_from_template
    merge_requires
}

###########################
## COMMAND: remote-setup ##
###########################

opt_upstream=
opt_origin=

function getopt_rs() { getopt_remote_setup "$@"; }
function getopt_remote_setup()
{
    while [ $# -gt 0 ]; do
        case $1 in
            --force)
                force=true
            ;;
            -o|--origin)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_origin=$1
            ;;
            -u|--upstream)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_upstream=$1
            ;;
            -f|--flux-git-repo)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_flux_git_repo=$1
        esac
        shift
    done
}

function command_rs() { command_remote_setup "$@"; }
function command_remote_setup()
{
    set -e
    line
    info Current remotes:
    git remote -v

    source_env $REPO_CONF

    echo "$opt_upstream$opt_origin$opt_flux_git_repo"
    if [ -z "$opt_upstream$opt_origin$opt_flux_git_repo" ]; then
        read_config upstream "Set UPSTREAM remote"
        read_config origin "Set ORIGIN remote"
        read_config flux_git_repo "Flux git repository"
    else
        [ -z "$opt_upstream" ] || read_config upstream "Set UPSTREAM remote"
        [ -z "$opt_origin" ] || read_config origin "Set ORIGIN remote"
        [ -z "$opt_flux_git_repo" ] || read_config flux_git_repo "Flux git repository"
    fi

    line
    info Will update to:
    info "-> upstream: $upstream"
    info "-> origin: $origin"
    info "-> flux_git_repo: $flux_git_repo"

    if ! $force; then
        if ! ask "Continue? [Y/n]"; then
            return
        fi
    fi

    save_repo_config
    update_git_remotes

    line
    info New remotes:
    git remote -v
}

###########################
## COMMAND: repo-pull    ##
###########################

function getopt_rp() { getopt_repo_pull "$@"; }
function getopt_repo_pull()
{
    :
}

function command_rp() { command_repo_pull "$@"; }
function command_repo_pull()
{
    cd $REPO_DIR
    for remote in origin upstream; do
        if ! git remote get-url $remote &>/dev/null; then
            info "Missing remote: $remote"
            ask_execute_command $0 remote-setup
            break
        fi
    done

    for remote in origin upstream; do
        info "--> remote:" $(git remote get-url $remote 2>/dev/null || echo '<none>')
        ask_execute_command git pull $remote main --tags
    done
}

#############################
## COMMAND: update-ssh-key ##
#############################

function getopt_usk() { getopt_update_ssh_key "$@"; }
function getopt_update_ssh_key()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            -k|--ssh-key-type)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_type=$1
            ;;
            -l|--ssh-key-length)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_length=$1
            ;;
            --force)
                force=true
            ;;
            *)
                if [ -z "$cluster_dir" ]; then
                    cluster_dir=$1
                else
                    invalid_argument $1
                fi
        esac
        shift
    done

    if [ $ssh_key_length -eq 0 ]; then
        local key_len=ssh_key_length_$ssh_key_type
        ssh_key_length=${!key_len}
    fi

    select_cluster $cluster_dir
}

function command_usk() { command_update_ssh_key "$@"; }
function command_update_ssh_key()
{
    if ! $force; then
        if ! ask "Generate new ssh keys now for $CLUSTER_DIR? [Y/n]"; then
            return
        fi
    fi

    if [ -e $CLUSTER_DIR/identity ]; then
        local bkp=$CLUSTER_DIR/identity.bkp$(date +%s)
        info Renaming existing ssh key $CLUSTER_DIR/identity to $bkp
        mv $CLUSTER_DIR/identity $bkp
    fi

    generate_ssh_key
}

###############################
## COMMAND: import-variables ##
###############################

import_var_prefixes=()
import_var_sources=()

function getopt_iv() { getopt_import_variables "$@"; }
function getopt_import_variables()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            *)
                [ $# -lt 2 ] && invalid_argument "missing source"
                import_var_prefixes+=( "$1" )
                import_var_sources+=( "$2" )
                shift
            ;;
        esac
        shift
    done
}

function prepend_prefix()
{
    local prefix="$1"
    local source="$2"

    echo "## Starting - auto-generated by $0 from $source"
    sed -e '/^\s*variable\s\+"\?'$prefix'_/!s/^\(\s*variable\s\+"\)\?\([a-zA-Z0-9]\+\)/\1'$prefix'_\2/'
    echo "## Finished - auto-generated by $0 from $source"
}

function command_iv() { command_import_variables "$@"; }
function command_import_variables()
{
    for i in $(seq 0 $(( ${#import_var_prefixes[*]} - 1 )) ); do
        prefix=${import_var_prefixes[$i]}
        source=${import_var_sources[$i]}

        if [[ "$source" =~ ^https?:// ]]; then
            curl -skL "$source" | prepend_prefix "$prefix" "$source"
        elif [ "$source" == "-" ] || [ -e "$source" ]; then
            cat "$source" | prepend_prefix "$prefix" "$source"
        else
            echo "File not found: $source"
            exit 1
        fi
    done
}

##########
## Main ##
##########

while [ $# -gt 0 ]; do
    case $1 in
        -h|--help)
            usage
        ;;
        -d|--debug)
            debug=true
            verbose=true
        ;;
        -v|--verbose)
            verbose=true
        ;;
        --)
            break
        ;;
        -*)
            invalid_argument $1
        ;;
        *)
            if [ -z "$command" ]; then
                command=$1
                shift
                break
            else
                exit_code=1
                usage
            fi
    esac
    shift
done

_command=${command//-/_}

if [ -z "$_command" ] || [ "$(type -t command_$_command)" != function ]; then
    usage
    exit 1
fi

if [ "$(type -t getopt_$_command)" == function ]; then
    eval getopt_$_command "$@"
fi

$debug && set -x
$verbose && dump_options

eval command_$_command
